// Объявление необходимых зависимостей
var Vec3 = require('vec3');
const {
    RaycastIterator
} = require('prismarine-world').iterators
module.exports = inject

// Экспорт функции, которая будет выполняться асинхронно
function inject(bot, options) {
    // Инициализация объекта autoclicker
    bot.autoclicker = { running: false };

    // Инициализация полей объекта autoclicker
    bot.autoclicker.interval = null; // Используется для хранения идентификатора интервала

    // Настройки автокликера
    bot.autoclicker.options = {
        max_distance: 5, // Максимальное расстояние для удара по сущностям (По умолчанию: 3.5)
        swing_through: ['experience_orb'], // Проходить сквозь сущности (По умолчанию: ['experience_orb'])
        blacklist: [''], // Исключить определенные сущности из удара (По умолчанию: ['player'])
        stop_on_window: false, // Останавливаться, если открыто окно (По умолчанию: true)
        always_swing: true, // Всегда махать, даже если сущности нет (По умолчанию: true)
        delay: 1500, // Задержка между ударами (По умолчанию: 1500 мс)
    }

    // Функция для запуска автокликера с возможностью указания интервала времени между ударами


    bot.autoclicker_start = (interval) => {
        if (interval && typeof interval === 'number') {
            bot.autoclicker.options.delay = interval; // Установка заданного интервала
        }

        // Проверка, чтобы избежать множественного запуска
        if (bot.autoclicker.interval) return;

        bot.autoclicker.interval = setInterval(async function () {
            let entity = entityAtCursor(bot.autoclicker.options.max_distance, bot.autoclicker.options.swing_through);

            if (bot.autoclicker.options.stop_on_window && bot.currentWindow) return;

            const sword = bot.inventory.items().find(item => item.name.includes('sword'));
            const invisibleEffect = bot.entity.effects;

            if (!entity || bot.autoclicker.options.blacklist.includes(entity.name)) {
                return bot.autoclicker.options.always_swing ? bot.swingArm() : null;
            }

            if (sword && invisibleEffect[14] && bot.food == 20) {
                bot.equip(sword, 'hand');
                bot.attack(entity, true);
            } else if (invisibleEffect[14] && bot.food == 20) {
                bot.attack(entity, true);
            }
        }, interval);
    }


    // Функция для остановки автокликера
    bot.autoclicker_stop = () => {
        bot.autoclicker.running = false; // Установить флаг остановки
        bot.autoclicker.interval = clearInterval(bot.autoclicker.interval); // Очистить интервал
    }

    // Функция для определения стойки для брони в радиусе
    function armorStandAtCursor(maxDistance = 5) {
        const armorStands = Object.values(bot.entities)
            .filter(entity => entity.type === 'armor_stand' && entity.position.distanceTo(bot.entity.position) <= maxDistance);

        if (armorStands.length > 0) {
            return armorStands[0]; // Возвращаем первую найденную стойку для брони
        } else {
            return null;
        }
    }

    // Функция для определения сущности под курсором с приоритетом на стойку для брони
    function entityAtCursor(maxDistance = 5, swing_through = ['experience_orb']) {
        let armorStand = armorStandAtCursor(maxDistance);
        if (armorStand) {
            return armorStand; // При наличии стойки для брони в радиусе возвращаем её
        }

        const block = bot.blockAtCursor(maxDistance);
        maxDistance = block?.intersect.distanceTo(bot.entity.position) ?? maxDistance;

        const entities = Object.values(bot.entities)
            .filter(entity => entity.type !== 'object' && entity.username !== bot.username && entity.position.distanceTo(bot.entity.position) <= maxDistance && !swing_through.includes(entity.name));

        const dir = new Vec3(-Math.sin(bot.entity.yaw) * Math.cos(bot.entity.pitch), Math.sin(bot.entity.pitch), -Math.cos(bot.entity.yaw) * Math.cos(bot.entity.pitch));
        const iterator = new RaycastIterator(bot.entity.position.offset(0, bot.entity.height, 0), dir.normalize(), maxDistance);

        let targetEntity = null;
        let targetDist = maxDistance;

        for (let i = 0; i < entities.length; i++) {
            const entity = entities[i];
            const w = entity.width / 2;

            const shapes = [
                [-w, 0, -w, w, entity.height + (entity.type === 'player' ? 0.18 : 0), w]
            ];
            const intersect = iterator.intersect(shapes, entity.position);
            if (intersect) {
                const entityDir = entity.position.minus(bot.entity.position);
                const sign = Math.sign(entityDir.dot(dir));
                if (sign !== -1) {
                    const dist = bot.entity.position.distanceTo(intersect.pos);
                    if (dist < targetDist) {
                        targetEntity = entity;
                        targetDist = dist;
                    }
                }
            }
        }

        return targetEntity;
    }
}